export AbstractSource, SourceLLMWDC, SourceXYMWDC, write_sourceCF!, read_sourceCF

abstract type AbstractSource end

using Printf

"""
    SourceLLMWDC(lon, lat, z, tbeg, trise, mag, strike, dip, rake)

Point double-couple source in geographic coordinates.
Fields correspond to the `llmwdc` format:
`lon`, `lat`, `z`, `tbeg`, `trise`, `mag`, `strike`, `dip`, `rake`
"""
struct SourceLLMWDC <: AbstractSource
    lon::Float64
    lat::Float64
    z::Float64
    tbeg::Float64
    trise::Float64
    mag::Float64
    strike::Float64
    dip::Float64
    rake::Float64
end

"""
    SourceXYMWDC(x, y, z, tbeg, trise, mag, strike, dip, rake)

Point double-couple source in projected XY coordinates.
Fields correspond to the `xymwdc` format:
`x`, `y`, `z`, `tbeg`, `trise`, `mag`, `strike`, `dip`, `rake`
"""
struct SourceXYMWDC <: AbstractSource
    x::Float64
    y::Float64
    z::Float64
    tbeg::Float64
    trise::Float64
    mag::Float64
    strike::Float64
    dip::Float64
    rake::Float64
end

"""
Compact REPL printing for `SourceLLMWDC`.
Example: SourceLLMWDC(lon=14.1338, lat=40.8262, z=1.879 km, tbeg=0.1 s, trise=4 s, Mw=3.9, DC[strike=243.4°, dip=31.6°, rake=-73.9°])
"""
function Base.show(io::IO, ::MIME"text/plain", s::SourceLLMWDC)
    print(io, "SourceLLMWDC(")
    print(io, "lon=", _num(s.lon), ", lat=", _num(s.lat), ", ")
    print(io, "z=", _num(s.z), " km, ")
    print(io, "tbeg=", _num(s.tbeg), " s, trise=", _num(s.trise), " s, ")
    print(io, "Mw=", _num(s.mag), ", ")
    print(io, "DC[strike=", _deg(s.strike), ", dip=", _deg(s.dip), ", rake=", _deg(s.rake), "]")
    print(io, ")")
end

"""
Compact REPL printing for `SourceXYMWDC`.
Example: SourceXYMWDC(x=0.0 km, y=0.0 km, z=1.879 km, tbeg=0.0 s, trise=2.5 s, Mw=3.9, DC[strike=243.4°, dip=31.6°, rake=-73.9°])
"""
function Base.show(io::IO, ::MIME"text/plain", s::SourceXYMWDC)
    print(io, "SourceXYMWDC(")
    print(io, "x=", _num(s.x), " km, y=", _num(s.y), " km, ")
    print(io, "z=", _num(s.z), " km, ")
    print(io, "tbeg=", _num(s.tbeg), " s, trise=", _num(s.trise), " s, ")
    print(io, "Mw=", _num(s.mag), ", ")
    print(io, "DC[strike=", _deg(s.strike), ", dip=", _deg(s.dip), ", rake=", _deg(s.rake), "]")
    print(io, ")")
end

"""
    write_sourceCF!(path::AbstractString, sources)

Write a `sourceCF.dat`-style file. The format section (`llmwdc` or `xymwdc`)
is selected based on the source type. Accepts a single source or a vector of sources.
"""
function write_sourceCF!(path::AbstractString, sources)
    if sources isa SourceLLMWDC || sources isa SourceXYMWDC
        return write_sourceCF!(path, [sources])
    elseif !(sources isa AbstractVector) || isempty(sources)
        error("Provide a SourceLLMWDC/SourceXYMWDC or a non-empty vector of them")
    end

    firstsrc = sources[1]
    is_ll = firstsrc isa SourceLLMWDC
    is_xy = firstsrc isa SourceXYMWDC
    is_ll || is_xy || error("Unsupported source type: $(typeof(firstsrc))")
    # Disallow mixed types to avoid ambiguity
    any(s -> !(s isa typeof(firstsrc)), sources) && error("All sources must be of the same type")

    open(path, "w") do io
        println(io, "#                                                                            -*- mode:sh -*-")
        println(io, "# sourceCF.dat")
        println(io, "#")
        println(io, "# Generated by OpenSWPCSource.write_sourceCF!")
        println(io, "# Lines starting from '#' and blank line will be omitted.")
        println(io)

        if is_ll
            println(io, "# format 'llmwdc': lon/lat, moment magnitude, double couple angles")
            println(io, "#")
            println(io, "#     lon     lat     z   tbeg  trise    mag   strike    dip   rake")
            println(io, "# --------------------------------------------------------------------------------------------")
            for s in sources
                @assert s isa SourceLLMWDC
                println(io, join((_num(s.lon), _num(s.lat), _num(s.z), _num(s.tbeg), _num(s.trise), _num(s.mag), _num(s.strike), _num(s.dip), _num(s.rake)), ' '))
            end
        else
            println(io, "# format 'xymwdc': xy, moment magnitude, double couple angles")
            println(io, "#")
            println(io, "#    x     y     z  tbeg  trise    mag   strike    dip   rake")
            println(io, "# --------------------------------------------------------------------------------------------")
            for s in sources
                @assert s isa SourceXYMWDC
                println(io, join((_num(s.x), _num(s.y), _num(s.z), _num(s.tbeg), _num(s.trise), _num(s.mag), _num(s.strike), _num(s.dip), _num(s.rake)), ' '))
            end
        end
    end
    return nothing
end

"""
    read_sourceCF(path::AbstractString; format::Symbol = :auto) -> Vector{<:Union{SourceLLMWDC,SourceXYMWDC}}

Read a `sourceCF.dat`-style file and return a vector of source objects.
`format` can be `:llmwdc`, `:xymwdc`, or `:auto` to detect from commented header lines.
"""
function read_sourceCF(path::AbstractString; format::Symbol = :auto)
    lines = readlines(path)

    fmt = format
    if fmt === :auto
        fmt = :unknown
        for ln in lines
            s = lowercase(strip(replace(ln, r"^#\s*" => "")))
            occursin("format 'llmwdc'", s) && (fmt = :llmwdc; break)
            occursin("format 'xymwdc'", s) && (fmt = :xymwdc; break)
        end
        fmt === :unknown && error("Could not detect format from header; pass format=:llmwdc or :xymwdc explicitly")
    elseif !(fmt in (:llmwdc, :xymwdc))
        error("Unsupported format=$(format); use :llmwdc, :xymwdc, or :auto")
    end

    out = SourceLLMWDC[]
    if fmt === :xymwdc
        out_xy = SourceXYMWDC[]
        for ln in lines
            stripln = strip(ln)
            isempty(stripln) && continue
            startswith(stripln, '#') && continue
            toks = split(stripln)
            length(toks) == 9 || continue
            try
                x, y, z, tbeg, trise, mag, strike, dip, rake = parse.(Float64, toks)
                push!(out_xy, SourceXYMWDC(x, y, z, tbeg, trise, mag, strike, dip, rake))
            catch
                # skip non-data lines
            end
        end
        return out_xy
    else
        for ln in lines
            stripln = strip(ln)
            isempty(stripln) && continue
            startswith(stripln, '#') && continue
            toks = split(stripln)
            length(toks) == 9 || continue
            try
                lon, lat, z, tbeg, trise, mag, strike, dip, rake = parse.(Float64, toks)
                push!(out, SourceLLMWDC(lon, lat, z, tbeg, trise, mag, strike, dip, rake))
            catch
                # skip non-data lines
            end
        end
        return out
    end
end
